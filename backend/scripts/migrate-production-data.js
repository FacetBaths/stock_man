const { MongoClient, ObjectId } = require('mongodb');

// Configuration
const PROD_CONNECTION = 'mongodb+srv://stockman:uwClxAy6dFHVW42r@cluster0.55teuc.mongodb.net/?retryWrites=true&w=majority';
const PROD_DATABASE = 'test';
const LOCAL_CONNECTION = 'mongodb://localhost:27017';
const LOCAL_DATABASE = 'stockmanager_dev';

async function migrateProductionData() {
  const prodClient = new MongoClient(PROD_CONNECTION);
  const localClient = new MongoClient(LOCAL_CONNECTION);
  
  try {
    // Connect to both databases
    await prodClient.connect();
    await localClient.connect();
    console.log('✅ Connected to both databases');
    
    const prodDB = prodClient.db(PROD_DATABASE);
    const localDB = localClient.db(LOCAL_DATABASE);
    
    // Step 1: Clear existing local data
    console.log('\\n🧹 Clearing existing local data...');
    await localDB.collection('categories').deleteMany({});
    await localDB.collection('skus').deleteMany({});
    await localDB.collection('skunews').deleteMany({});
    await localDB.collection('itemnews').deleteMany({});
    await localDB.collection('inventory').deleteMany({});
    await localDB.collection('tags').deleteMany({});
    await localDB.collection('tagnews').deleteMany({});
    console.log('   Local collections cleared');
    \n    // Step 2: Create categories from product types\n    console.log('\\n📁 Creating categories...');\n    const productTypes = [\n      { name: 'walls', description: 'Wall panels and components' },\n      { name: 'accessories', description: 'Bathroom accessories and fixtures' },\n      { name: 'bases', description: 'Shower and tub bases' },\n      { name: 'tubs', description: 'Bathtubs and tub components' },\n      { name: 'vanities', description: 'Vanities and vanity components' },\n      { name: 'toilets', description: 'Toilets and toilet components' },\n      { name: 'shower doors', description: 'Shower doors and enclosures' },\n      { name: 'raw materials', description: 'Raw materials and supplies' },\n      { name: 'miscellaneous', description: 'Other items' }\n    ];\n    \n    const categoryMap = {};\n    for (const cat of productTypes) {\n      const result = await localDB.collection('categories').insertOne({\n        name: cat.name,\n        description: cat.description,\n        is_active: true,\n        createdAt: new Date(),\n        updatedAt: new Date()\n      });\n      categoryMap[cat.name] = result.insertedId;\n      console.log(`   Created category: ${cat.name}`);\n    }\n    \n    // Step 3: Migrate SKUs\n    console.log('\\n🏷️  Migrating SKUs...');\n    const prodSKUs = await prodDB.collection('skus').find({}).toArray();\n    const skuMap = {};\n    \n    for (const sku of prodSKUs) {\n      // Map product type to category\n      const categoryName = sku.product_type === 'shower_door' ? 'shower doors' : \n                          sku.product_type === 'raw_material' ? 'raw materials' : \n                          sku.product_type + 's';\n      \n      const newSKU = {\n        sku_code: sku.sku_code,\n        name: sku.sku_code, // Will be updated when we get product details\n        description: sku.description || '',\n        category_id: categoryMap[categoryName] || categoryMap['miscellaneous'],\n        unit_cost: sku.current_cost || 0,\n        barcode: sku.barcode || null,\n        manufacturer_part_number: sku.manufacturer_model || null,\n        specifications: {},\n        dimensions: null,\n        weight: null,\n        color: null,\n        finish: null,\n        brand: null,\n        model: null,\n        is_bundle: sku.is_bundle || false,\n        bundle_items: sku.bundle_items || [],\n        minimum_stock_level: sku.stock_thresholds?.understocked || 0,\n        maximum_stock_level: sku.stock_thresholds?.overstocked || null,\n        supplier_info: null,\n        notes: sku.notes || '',\n        is_active: sku.status === 'active',\n        created_by: sku.created_by || 'migration',\n        last_updated_by: sku.last_updated_by || 'migration',\n        createdAt: sku.createdAt || new Date(),\n        updatedAt: sku.updatedAt || new Date()\n      };\n      \n      const result = await localDB.collection('skunews').insertOne(newSKU);\n      skuMap[sku._id.toString()] = result.insertedId;\n      console.log(`   Migrated SKU: ${sku.sku_code}`);\n    }\n    \n    // Step 4: Migrate Items\n    console.log('\\n📦 Migrating items...');\n    const prodItems = await prodDB.collection('items').find({}).toArray();\n    \n    for (const item of prodItems) {\n      // Handle items with quantity > 1 by creating multiple individual items\n      const quantity = item.quantity || 1;\n      \n      for (let i = 0; i < quantity; i++) {\n        const newItem = {\n          sku_id: item.sku_id ? skuMap[item.sku_id.toString()] : null,\n          serial_number: `${item._id.toString()}-${i + 1}`,\n          condition: 'good', // Default condition\n          status: 'available', // Default status\n          location: item.location || 'Warehouse',\n          purchase_date: item.createdAt || new Date(),\n          purchase_cost: item.cost || 0,\n          notes: `Migrated from production. ${item.notes || ''}`.trim(),\n          warranty_info: null,\n          maintenance_history: [],\n          created_by: 'migration',\n          last_updated_by: 'migration',\n          createdAt: item.createdAt || new Date(),\n          updatedAt: item.updatedAt || new Date()\n        };\n        \n        await localDB.collection('itemnews').insertOne(newItem);\n      }\n      \n      console.log(`   Migrated item: ${item.product_type} (${quantity} units)`);\n    }\n    \n    // Step 5: Migrate Tags\n    console.log('\\n🏷️  Migrating tags...');\n    const prodTags = await prodDB.collection('tags').find({}).toArray();\n    \n    for (const tag of prodTags) {\n      const newTag = {\n        customer_name: tag.customer_name,\n        project_name: tag.project_name || null,\n        tag_type: tag.tag_type,\n        status: tag.status === 'active' ? 'active' : 'completed',\n        due_date: tag.due_date || null,\n        notes: tag.notes || '',\n        items: [], // Will be populated based on item relationships\n        total_estimated_value: 0,\n        created_by: tag.created_by || 'migration',\n        last_updated_by: 'migration',\n        createdAt: tag.createdAt || new Date(),\n        updatedAt: tag.updatedAt || new Date()\n      };\n      \n      await localDB.collection('tagnews').insertOne(newTag);\n      console.log(`   Migrated tag: ${tag.customer_name} (${tag.tag_type})`);\n    }\n    \n    // Step 6: Create inventory records\n    console.log('\\n📊 Creating inventory records...');\n    const skus = await localDB.collection('skunews').find({}).toArray();\n    \n    for (const sku of skus) {\n      // Count items for this SKU\n      const itemCount = await localDB.collection('itemnews').countDocuments({ sku_id: sku._id });\n      \n      const inventoryRecord = {\n        sku_id: sku._id,\n        available_quantity: itemCount,\n        reserved_quantity: 0,\n        broken_quantity: 0,\n        loaned_quantity: 0,\n        total_quantity: itemCount,\n        minimum_stock_level: sku.minimum_stock_level || 0,\n        reorder_point: 5,\n        maximum_stock_level: sku.maximum_stock_level,\n        average_cost: sku.unit_cost || 0,\n        total_value: (sku.unit_cost || 0) * itemCount,\n        primary_location: 'Warehouse',\n        locations: [{\n          location_name: 'Warehouse',\n          quantity: itemCount\n        }],\n        last_movement_date: new Date(),\n        last_updated_by: 'migration',\n        is_active: true,\n        is_low_stock: itemCount <= (sku.minimum_stock_level || 5),\n        is_out_of_stock: itemCount === 0,\n        is_overstock: false,\n        movement_history: [{\n          type: 'migration',\n          quantity: itemCount,\n          from_status: null,\n          to_status: 'available',\n          date: new Date(),\n          reason: 'Initial migration from production data',\n          updated_by: 'migration'\n        }],\n        createdAt: new Date(),\n        updatedAt: new Date()\n      };\n      \n      await localDB.collection('inventory').insertOne(inventoryRecord);\n      console.log(`   Created inventory for: ${sku.sku_code} (${itemCount} items)`);\n    }\n    \n    // Step 7: Generate summary report\n    console.log('\\n📋 Migration Summary:');\n    const categoriesCount = await localDB.collection('categories').countDocuments();\n    const skusCount = await localDB.collection('skunews').countDocuments();\n    const itemsCount = await localDB.collection('itemnews').countDocuments();\n    const inventoryCount = await localDB.collection('inventory').countDocuments();\n    const tagsCount = await localDB.collection('tagnews').countDocuments();\n    \n    console.log(`   ✅ Categories: ${categoriesCount}`);\n    console.log(`   ✅ SKUs: ${skusCount}`);\n    console.log(`   ✅ Items: ${itemsCount}`);\n    console.log(`   ✅ Inventory records: ${inventoryCount}`);\n    console.log(`   ✅ Tags: ${tagsCount}`);\n    \n    // Show inventory totals by category\n    const inventorySummary = await localDB.collection('inventory').aggregate([\n      {\n        $lookup: {\n          from: 'skunews',\n          localField: 'sku_id',\n          foreignField: '_id',\n          as: 'sku'\n        }\n      },\n      { $unwind: '$sku' },\n      {\n        $lookup: {\n          from: 'categories',\n          localField: 'sku.category_id',\n          foreignField: '_id',\n          as: 'category'\n        }\n      },\n      { $unwind: '$category' },\n      {\n        $group: {\n          _id: '$category.name',\n          total_quantity: { $sum: '$total_quantity' },\n          total_value: { $sum: '$total_value' }\n        }\n      },\n      { $sort: { _id: 1 } }\n    ]).toArray();\n    \n    console.log('\\n📊 Inventory by Category:');\n    let grandTotal = 0, grandValue = 0;\n    inventorySummary.forEach(cat => {\n      console.log(`   ${cat._id}: ${cat.total_quantity} items ($${cat.total_value})`);\n      grandTotal += cat.total_quantity;\n      grandValue += cat.total_value;\n    });\n    console.log(`   TOTAL: ${grandTotal} items ($${grandValue})`);\n    \n    console.log('\\n🎉 Migration completed successfully!');\n    \n  } catch (error) {\n    console.error('❌ Migration failed:', error);\n  } finally {\n    await prodClient.close();\n    await localClient.close();\n  }\n}\n\n// Add command line argument handling\nif (process.argv.includes('--confirm')) {\n  migrateProductionData();\n} else {\n  console.log('⚠️  This script will migrate production data to your local database.');\n  console.log('   It will CLEAR existing data in the local database.');\n  console.log('   Run with --confirm to proceed:');\n  console.log('');\n  console.log('   node scripts/migrate-production-data.js --confirm');\n  console.log('');\n}
