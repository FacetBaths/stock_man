import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import type { 
  SKU, 
  SKUResponse, 
  CreateSKURequest, 
  UpdateSKURequest, 
  AddCostRequest,
  StockStatus
} from '@/types'
import { skuApi } from '@/utils/api'

export const useSKUStore = defineStore('sku', () => {
  // State
  const skus = ref<SKU[]>([])
  const currentSKU = ref<SKU | null>(null)
  const isLoading = ref(false)
  const error = ref<string | null>(null)
  const pagination = ref({
    totalSkus: 0,
    totalPages: 0,
    currentPage: 1,
    limit: 50
  })

  // Filters
  const filters = ref({
    product_type: '',
    status: 'active',
    search: ''
  })

  // Computed
  const activeSKUs = computed(() => skus.value.filter(sku => sku.status === 'active'))
  const inactiveSKUs = computed(() => skus.value.filter(sku => sku.status === 'inactive'))
  const discontinuedSKUs = computed(() => skus.value.filter(sku => sku.status === 'discontinued'))

  const skusByStockStatus = computed(() => {
    const result = {
      understocked: [] as SKU[],
      adequate: [] as SKU[],
      overstocked: [] as SKU[]
    }
    
    skus.value.forEach(sku => {
      if (sku.stockStatus) {
        result[sku.stockStatus].push(sku)
      }
    })
    
    return result
  })

  const skuStats = computed(() => {
    const total = skus.value.length
    const active = activeSKUs.value.length
    const withBarcodes = skus.value.filter(sku => sku.barcode).length
    const autoGenerated = skus.value.filter(sku => sku.is_auto_generated).length
    const totalQuantity = skus.value.reduce((sum, sku) => sum + (sku.totalQuantity || 0), 0)
    const totalValue = skus.value.reduce((sum, sku) => sum + (sku.current_cost * (sku.totalQuantity || 0)), 0)

    return {
      total,
      active,
      withBarcodes,
      autoGenerated,
      totalQuantity,
      totalValue,
      understocked: skusByStockStatus.value.understocked.length,
      overstocked: skusByStockStatus.value.overstocked.length
    }
  })

  // Actions
  const fetchSKUs = async (params?: {
    product_type?: string
    status?: string
    search?: string
    page?: number
    limit?: number
  }) => {
    try {
      isLoading.value = true
      error.value = null

      const response = await skuApi.getSKUs({
        ...filters.value,
        ...params
      })

      skus.value = response.skus
      pagination.value = {
        totalSkus: response.totalSkus,
        totalPages: response.totalPages,
        currentPage: response.currentPage,
        limit: params?.limit || pagination.value.limit
      }

      return response
    } catch (err: any) {
      error.value = err.response?.data?.message || 'Failed to fetch SKUs'
      throw err
    } finally {
      isLoading.value = false
    }
  }

  const fetchSKU = async (id: string) => {
    try {
      isLoading.value = true
      error.value = null

      const sku = await skuApi.getSKU(id)
      currentSKU.value = sku

      // Update in list if exists
      const index = skus.value.findIndex(s => s._id === id)
      if (index !== -1) {
        skus.value[index] = sku
      }

      return sku
    } catch (err: any) {
      error.value = err.response?.data?.message || 'Failed to fetch SKU'
      throw err
    } finally {
      isLoading.value = false
    }
  }

  const createSKU = async (skuData: CreateSKURequest) => {
    try {
      isLoading.value = true
      error.value = null

      const newSKU = await skuApi.createSKU(skuData)
      skus.value.unshift(newSKU)
      pagination.value.totalSkus += 1

      return newSKU
    } catch (err: any) {
      error.value = err.response?.data?.message || 'Failed to create SKU'
      throw err
    } finally {
      isLoading.value = false
    }
  }

  const updateSKU = async (id: string, updates: UpdateSKURequest) => {
    try {
      isLoading.value = true
      error.value = null

      const updatedSKU = await skuApi.updateSKU(id, updates)
      
      // Update in list
      const index = skus.value.findIndex(s => s._id === id)
      if (index !== -1) {
        skus.value[index] = updatedSKU
      }

      // Update current SKU if it's the same
      if (currentSKU.value?._id === id) {
        currentSKU.value = updatedSKU
      }

      return updatedSKU
    } catch (err: any) {
      error.value = err.response?.data?.message || 'Failed to update SKU'
      throw err
    } finally {
      isLoading.value = false
    }
  }

  const deleteSKU = async (id: string) => {
    try {
      isLoading.value = true
      error.value = null

      await skuApi.deleteSKU(id)
      
      // Remove from list
      const index = skus.value.findIndex(s => s._id === id)
      if (index !== -1) {
        skus.value.splice(index, 1)
        pagination.value.totalSkus -= 1
      }

      // Clear current SKU if it was deleted
      if (currentSKU.value?._id === id) {
        currentSKU.value = null
      }
    } catch (err: any) {
      error.value = err.response?.data?.message || 'Failed to delete SKU'
      throw err
    } finally {
      isLoading.value = false
    }
  }

  const generateSKUCode = async (data: {
    product_type: string
    product_details: string
    template?: string
  }) => {
    try {
      const response = await skuApi.generateSKUCode(data)
      return response.sku_code
    } catch (err: any) {
      error.value = err.response?.data?.message || 'Failed to generate SKU code'
      throw err
    }
  }

  const addCost = async (id: string, costData: AddCostRequest) => {
    try {
      isLoading.value = true
      error.value = null

      const updatedSKU = await skuApi.addCost(id, costData)
      
      // Update in list
      const index = skus.value.findIndex(s => s._id === id)
      if (index !== -1) {
        skus.value[index] = updatedSKU
      }

      // Update current SKU if it's the same
      if (currentSKU.value?._id === id) {
        currentSKU.value = updatedSKU
      }

      return updatedSKU
    } catch (err: any) {
      error.value = err.response?.data?.message || 'Failed to add cost'
      throw err
    } finally {
      isLoading.value = false
    }
  }

  const searchByBarcode = async (barcode: string) => {
    try {
      error.value = null
      const sku = await skuApi.searchByBarcode(barcode)
      return sku
    } catch (err: any) {
      if (err.response?.status === 404) {
        return null // Barcode not found
      }
      error.value = err.response?.data?.message || 'Failed to search by barcode'
      throw err
    }
  }

  const findSKUByBarcode = async (barcode: string) => {
    // Alias for searchByBarcode for consistency
    return await searchByBarcode(barcode)
  }

  const getSKUByCode = (skuCode: string) => {
    return skus.value.find(sku => sku.sku_code === skuCode)
  }

  const getSKUsByProduct = (productType: string) => {
    return skus.value.filter(sku => sku.product_type === productType)
  }

  const getSKUsByStatus = (status: string) => {
    return skus.value.filter(sku => sku.status === status)
  }

  const updateFilters = (newFilters: Partial<typeof filters.value>) => {
    filters.value = { ...filters.value, ...newFilters }
    fetchSKUs({ page: 1 }) // Reset to first page when filters change
  }

  const clearFilters = () => {
    filters.value = {
      product_type: '',
      status: 'active',
      search: ''
    }
    fetchSKUs({ page: 1 })
  }

  const clearError = () => {
    error.value = null
  }

  const setCurrentSKU = (sku: SKU | null) => {
    currentSKU.value = sku
  }

  return {
    // State
    skus,
    currentSKU,
    isLoading,
    error,
    pagination,
    filters,

    // Computed
    activeSKUs,
    inactiveSKUs,
    discontinuedSKUs,
    skusByStockStatus,
    skuStats,

    // Actions
    fetchSKUs,
    fetchSKU,
    createSKU,
    updateSKU,
    deleteSKU,
    generateSKUCode,
    addCost,
    searchByBarcode,
    findSKUByBarcode,
    getSKUByCode,
    getSKUsByProduct,
    getSKUsByStatus,
    updateFilters,
    clearFilters,
    clearError,
    setCurrentSKU
  }
})
