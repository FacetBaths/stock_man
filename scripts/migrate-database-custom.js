#!/usr/bin/env node

/**
 * Custom Database Migration Script
 * Tailored for the specific data structure found in this database
 */

const mongoose = require('mongoose');
require('dotenv').config();

// Import new models (redesigned structure)
const { 
  Customer, 
  Category, 
  SKUNew, 
  ItemNew, 
  TagNew, 
  Inventory, 
  AuditLog 
} = require('../backend/src/models/newModels');

// Define simplified old models based on actual data structure
const OldSKUSchema = new mongoose.Schema({}, { strict: false, collection: 'skus' });
const OldItemSchema = new mongoose.Schema({}, { strict: false, collection: 'items' });
const OldTagSchema = new mongoose.Schema({}, { strict: false, collection: 'tags' });

const OldSKU = mongoose.model('OldSKU', OldSKUSchema);
const OldItem = mongoose.model('OldItem', OldItemSchema);
const OldTag = mongoose.model('OldTag', OldTagSchema);

// Migration configuration
const MIGRATION_CONFIG = {
  batchSize: 100,
  logLevel: 'info',
  dryRun: false,
  continueOnError: false,
};

// Migration state tracking
let migrationState = {
  startTime: new Date(),
  errors: [],
  warnings: [],
  stats: {
    customersCreated: 0,
    categoriesCreated: 0,
    skusProcessed: 0,
    itemsProcessed: 0,
    tagsProcessed: 0,
    inventoryCreated: 0,
    auditLogsCreated: 0
  }
};

// Utility functions
const log = {
  debug: (msg) => MIGRATION_CONFIG.logLevel === 'debug' && console.log(`ðŸ” DEBUG: ${msg}`),
  info: (msg) => ['debug', 'info'].includes(MIGRATION_CONFIG.logLevel) && console.log(`â„¹ï¸  INFO: ${msg}`),
  warn: (msg) => ['debug', 'info', 'warn'].includes(MIGRATION_CONFIG.logLevel) && console.warn(`âš ï¸  WARN: ${msg}`),
  error: (msg) => console.error(`âŒ ERROR: ${msg}`)
};

const handleError = (error, context) => {
  const errorInfo = {
    context,
    error: error.message,
    stack: error.stack,
    timestamp: new Date()
  };
  
  migrationState.errors.push(errorInfo);
  log.error(`${context}: ${error.message}`);\n  \n  if (!MIGRATION_CONFIG.continueOnError) {\n    throw error;\n  }\n};\n\n// Step 1: Analyze existing data\nasync function analyzeExistingData() {\n  log.info('ðŸ“Š Analyzing existing data structure...');\n  \n  const analysis = {\n    skus: await OldSKU.countDocuments(),\n    items: await OldItem.countDocuments(),\n    tags: await OldTag.countDocuments()\n  };\n  \n  log.info('Current data counts:');\n  Object.entries(analysis).forEach(([key, count]) => {\n    log.info(`  ${key}: ${count} documents`);\n  });\n  \n  // Identify unique customers from tags (stored as customer_name)\n  const uniqueCustomers = await OldTag.distinct('customer_name');\n  log.info(`  unique customers: ${uniqueCustomers.length}`);\n  \n  return {\n    counts: analysis,\n    uniqueCustomers\n  };\n}\n\n// Step 2: Create base categories\nasync function createBaseCategories() {\n  log.info('ðŸ“ Creating base categories...');\n  \n  const baseCategories = [\n    {\n      name: 'Walls',\n      slug: 'walls',\n      description: 'Wall panels and related items',\n      is_active: true\n    },\n    {\n      name: 'Accessories',\n      slug: 'accessories',\n      description: 'Bathroom accessories and fittings',\n      is_active: true\n    },\n    {\n      name: 'Toilets',\n      slug: 'toilets',\n      description: 'Toilets and related fixtures',\n      is_active: true\n    },\n    {\n      name: 'General',\n      slug: 'general',\n      description: 'General inventory items',\n      is_active: true\n    }\n  ];\n  \n  const createdCategories = {};\n  \n  for (const categoryData of baseCategories) {\n    if (!MIGRATION_CONFIG.dryRun) {\n      const category = await Category.create(categoryData);\n      createdCategories[categoryData.slug] = category._id;\n      migrationState.stats.categoriesCreated++;\n      log.debug(`Created category: ${categoryData.name}`);\n    } else {\n      log.debug(`DRY RUN: Would create category: ${categoryData.name}`);\n    }\n  }\n  \n  return createdCategories;\n}\n\n// Step 3: Create customers from tag data\nasync function createCustomersFromTags() {\n  log.info('ðŸ‘¥ Creating customers from tag data...');\n  \n  // Get unique customer strings from tags\n  const uniqueCustomers = await OldTag.distinct('customer_name');\n  const customerMapping = {};\n  \n  for (const customerName of uniqueCustomers) {\n    if (!customerName || customerName.trim() === '') continue;\n    \n    const cleanName = customerName.trim();\n    \n    const customerData = {\n      company_name: cleanName,\n      contact_name: cleanName,\n      email: '',\n      phone: '',\n      status: 'active',\n      customer_type: 'business',\n      billing_address: {\n        street: '',\n        city: '',\n        state: '',\n        zip: '',\n        country: 'USA'\n      },\n      shipping_address: {\n        street: '',\n        city: '',\n        state: '',\n        zip: '',\n        country: 'USA'\n      },\n      notes: `Migrated from old system. Original name: \"${customerName}\"`\n    };\n    \n    try {\n      if (!MIGRATION_CONFIG.dryRun) {\n        const customer = await Customer.create(customerData);\n        customerMapping[customerName] = customer._id;\n        migrationState.stats.customersCreated++;\n        log.debug(`Created customer: ${cleanName}`);\n      } else {\n        log.debug(`DRY RUN: Would create customer: ${cleanName}`);\n      }\n    } catch (error) {\n      handleError(error, `Creating customer: ${cleanName}`);\n    }\n  }\n  \n  return customerMapping;\n}\n\n// Step 4: Migrate SKUs to new structure\nasync function migrateSKUs(categoryMapping) {\n  log.info('ðŸ“¦ Migrating SKUs to new structure...');\n  \n  const skuMapping = {};\n  const oldSKUs = await OldSKU.find();\n  \n  for (const oldSKU of oldSKUs) {\n    try {\n      // Determine category based on product_type\n      let categoryId = categoryMapping['general'];\n      \n      if (oldSKU.product_type === 'wall') {\n        categoryId = categoryMapping['walls'];\n      } else if (oldSKU.product_type === 'accessory') {\n        categoryId = categoryMapping['accessories'];\n      } else if (oldSKU.product_type === 'toilet') {\n        categoryId = categoryMapping['toilets'];\n      }\n      \n      const newSKUData = {\n        sku_code: oldSKU.sku_code || `SKU-${oldSKU._id}`,\n        name: oldSKU.description || `${oldSKU.product_type} - ${oldSKU.sku_code}` || 'Unknown Product',\n        description: oldSKU.description || oldSKU.notes || '',\n        category_id: categoryId,\n        \n        // Pricing information\n        unit_cost: oldSKU.current_cost || 0,\n        unit_price: oldSKU.current_cost || 0,\n        \n        // Product details\n        manufacturer_model: oldSKU.manufacturer_model || '',\n        barcode: oldSKU.barcode || '',\n        \n        // Status\n        is_active: oldSKU.status === 'active',\n        is_lendable: false,\n        \n        // Bundle info\n        is_bundle: oldSKU.is_bundle || false,\n        \n        // Metadata\n        notes: `Migrated from old SKU system. Original product_type: ${oldSKU.product_type}`,\n        \n        // Tracking\n        created_by: oldSKU.created_by || 'migration-script',\n        last_updated_by: oldSKU.last_updated_by || 'migration-script'\n      };\n      \n      if (!MIGRATION_CONFIG.dryRun) {\n        const newSKU = await SKUNew.create(newSKUData);\n        skuMapping[oldSKU._id.toString()] = newSKU._id;\n        migrationState.stats.skusProcessed++;\n        \n        // Create initial inventory record\n        await Inventory.create({\n          sku_id: newSKU._id,\n          total_quantity: 0,\n          available_quantity: 0,\n          reserved_quantity: 0,\n          broken_quantity: 0,\n          loaned_quantity: 0,\n          minimum_stock_level: oldSKU.stock_thresholds?.understocked || 0,\n          maximum_stock_level: oldSKU.stock_thresholds?.overstocked || null,\n          last_updated_by: 'migration-script'\n        });\n        migrationState.stats.inventoryCreated++;\n        \n        log.debug(`Migrated SKU: ${oldSKU.sku_code}`);\n      } else {\n        log.debug(`DRY RUN: Would migrate SKU: ${oldSKU.sku_code}`);\n      }\n      \n    } catch (error) {\n      handleError(error, `Migrating SKU: ${oldSKU.sku_code || oldSKU._id}`);\n    }\n  }\n  \n  return skuMapping;\n}\n\n// Step 5: Migrate Items to new structure\nasync function migrateItems(skuMapping) {\n  log.info('ðŸ·ï¸  Migrating Items to new structure...');\n  \n  const itemMapping = {};\n  const oldItems = await OldItem.find();\n  \n  for (const oldItem of oldItems) {\n    try {\n      // Find the corresponding new SKU\n      const newSKUId = skuMapping[oldItem.sku_id?.toString()];\n      if (!newSKUId) {\n        migrationState.warnings.push(`Item ${oldItem._id} references non-existent SKU ${oldItem.sku_id}`);\n        continue;\n      }\n      \n      // Create multiple items based on quantity (if quantity > 1)\n      const itemQuantity = oldItem.quantity || 1;\n      \n      for (let i = 0; i < itemQuantity; i++) {\n        const newItemData = {\n          sku_id: newSKUId,\n          serial_number: '',\n          condition: 'good',\n          status: 'available',\n          location: oldItem.location || 'warehouse',\n          purchase_cost: oldItem.cost || 0,\n          notes: `Migrated from old item system. Item ${i + 1} of ${itemQuantity}. Original notes: ${oldItem.notes || ''}`,\n          created_by: 'migration-script',\n          last_updated_by: 'migration-script'\n        };\n        \n        if (!MIGRATION_CONFIG.dryRun) {\n          const newItem = await ItemNew.create(newItemData);\n          itemMapping[`${oldItem._id.toString()}-${i}`] = newItem._id;\n          \n          // Update inventory quantities\n          await updateInventoryForItem(newSKUId, 'available', 1, 'add');\n          \n          migrationState.stats.itemsProcessed++;\n        } else {\n          log.debug(`DRY RUN: Would migrate Item ${i + 1}/${itemQuantity} from: ${oldItem._id}`);\n        }\n      }\n      \n      log.debug(`Migrated Item: ${oldItem._id} (${itemQuantity} units)`);\n      \n    } catch (error) {\n      handleError(error, `Migrating Item: ${oldItem._id}`);\n    }\n  }\n  \n  return itemMapping;\n}\n\n// Helper function to update inventory quantities\nasync function updateInventoryForItem(skuId, status, quantity, operation = 'add') {\n  try {\n    const inventory = await Inventory.findOne({ sku_id: skuId });\n    if (!inventory) return;\n    \n    const multiplier = operation === 'add' ? 1 : -1;\n    const updateQuantity = quantity * multiplier;\n    \n    switch (status) {\n      case 'available':\n        inventory.available_quantity += updateQuantity;\n        break;\n      case 'reserved':\n        inventory.reserved_quantity += updateQuantity;\n        break;\n      case 'broken':\n        inventory.broken_quantity += updateQuantity;\n        break;\n      case 'loaned':\n        inventory.loaned_quantity += updateQuantity;\n        break;\n      default:\n        inventory.available_quantity += updateQuantity;\n    }\n    \n    await inventory.save();\n  } catch (error) {\n    handleError(error, `Updating inventory for SKU: ${skuId}`);\n  }\n}\n\n// Step 6: Migrate Tags to new structure\nasync function migrateTags(customerMapping, skuMapping) {\n  log.info('ðŸ·ï¸  Migrating Tags to new structure...');\n  \n  const oldTags = await OldTag.find();\n  \n  for (const oldTag of oldTags) {\n    try {\n      // Find customer\n      const customerId = customerMapping[oldTag.customer_name];\n      if (!customerId) {\n        migrationState.warnings.push(`Tag ${oldTag._id} references unknown customer: ${oldTag.customer_name}`);\n        continue;\n      }\n      \n      // Map old sku_items to new items\n      const newItems = [];\n      if (oldTag.sku_items && Array.isArray(oldTag.sku_items)) {\n        for (const oldSkuItem of oldTag.sku_items) {\n          const newSKUId = skuMapping[oldSkuItem.sku_id?.toString()];\n          if (!newSKUId) {\n            migrationState.warnings.push(`Tag ${oldTag._id} references unknown SKU ${oldSkuItem.sku_id}`);\n            continue;\n          }\n          \n          // Find items for this SKU to reference\n          const items = await ItemNew.find({ sku_id: newSKUId }).limit(oldSkuItem.quantity || 1);\n          \n          for (const item of items) {\n            newItems.push({\n              item_id: item._id,\n              quantity: 1, // Each item record represents 1 unit\n              remaining_quantity: oldSkuItem.remaining_quantity > 0 ? 1 : 0,\n              notes: ''\n            });\n          }\n        }\n      }\n      \n      if (newItems.length === 0) {\n        migrationState.warnings.push(`Tag ${oldTag._id} has no valid items`);\n        continue;\n      }\n      \n      const newTagData = {\n        customer_id: customerId,\n        tag_type: oldTag.tag_type === 'stock' ? 'reserved' : oldTag.tag_type || 'reserved',\n        status: oldTag.status || 'active',\n        items: newItems,\n        notes: oldTag.notes || 'Migrated from old tag system',\n        due_date: oldTag.due_date,\n        project_name: '',\n        created_by: oldTag.created_by || 'migration-script',\n        last_updated_by: 'migration-script'\n      };\n      \n      if (!MIGRATION_CONFIG.dryRun) {\n        const newTag = await TagNew.create(newTagData);\n        migrationState.stats.tagsProcessed++;\n        \n        // Log the tag creation\n        await AuditLog.logTagEvent({\n          event_type: 'tag_created',\n          tag_id: newTag._id,\n          customer_id: customerId,\n          user_id: 'migration-script',\n          user_name: 'Migration Script',\n          tag_type: newTag.tag_type,\n          items_count: newItems.length,\n          total_quantity: newItems.reduce((sum, item) => sum + item.quantity, 0),\n          reason: 'Data migration from old system'\n        });\n        migrationState.stats.auditLogsCreated++;\n        \n        log.debug(`Migrated Tag: ${oldTag._id}`);\n      } else {\n        log.debug(`DRY RUN: Would migrate Tag: ${oldTag._id}`);\n      }\n      \n    } catch (error) {\n      handleError(error, `Migrating Tag: ${oldTag._id}`);\n    }\n  }\n}\n\n// Step 7: Create migration audit log\nasync function createMigrationAuditLog() {\n  if (!MIGRATION_CONFIG.dryRun) {\n    await AuditLog.logSystemEvent({\n      event_type: 'migration_completed',\n      user_id: 'migration-script',\n      user_name: 'Migration Script',\n      action: 'Database schema migration',\n      description: `Completed migration from old schema to new architecture. Stats: ${JSON.stringify(migrationState.stats)}`,\n      metadata: {\n        duration_ms: Date.now() - migrationState.startTime.getTime(),\n        errors_count: migrationState.errors.length,\n        warnings_count: migrationState.warnings.length,\n        stats: migrationState.stats\n      },\n      severity: 'medium'\n    });\n    migrationState.stats.auditLogsCreated++;\n  }\n}\n\n// Step 8: Validate migration results\nasync function validateMigration() {\n  log.info('âœ… Validating migration results...');\n  \n  const validation = {\n    customers: await Customer.countDocuments(),\n    categories: await Category.countDocuments(),\n    skus: await SKUNew.countDocuments(),\n    items: await ItemNew.countDocuments(),\n    tags: await TagNew.countDocuments(),\n    inventory: await Inventory.countDocuments(),\n    auditLogs: await AuditLog.countDocuments()\n  };\n  \n  log.info('New data counts:');\n  Object.entries(validation).forEach(([key, count]) => {\n    log.info(`  ${key}: ${count} documents`);\n  });\n  \n  // Validate referential integrity\n  log.info('ðŸ”— Checking referential integrity...');\n  \n  // Check that all items reference valid SKUs\n  const itemsWithValidSKUs = await ItemNew.aggregate([\n    {\n      $lookup: {\n        from: 'skunews',\n        localField: 'sku_id',\n        foreignField: '_id',\n        as: 'sku'\n      }\n    },\n    {\n      $match: { sku: { $ne: [] } }\n    },\n    {\n      $count: 'valid_items'\n    }\n  ]);\n  \n  const totalItems = await ItemNew.countDocuments();\n  const validItems = itemsWithValidSKUs.length > 0 ? itemsWithValidSKUs[0].valid_items : 0;\n  \n  if (validItems === totalItems) {\n    log.info('âœ… All items have valid SKU references');\n  } else {\n    log.warn(`${totalItems - validItems} items have invalid SKU references`);\n  }\n  \n  return validation;\n}\n\n// Main migration function\nasync function runMigration() {\n  try {\n    log.info('ðŸš€ Starting custom database migration...');\n    log.info(`Configuration: ${JSON.stringify(MIGRATION_CONFIG, null, 2)}`);\n    \n    // Step 1: Analyze existing data\n    const analysis = await analyzeExistingData();\n    \n    // Step 2: Create base categories\n    const categoryMapping = await createBaseCategories();\n    \n    // Step 3: Create customers from tag data\n    const customerMapping = await createCustomersFromTags();\n    \n    // Step 4: Migrate SKUs\n    const skuMapping = await migrateSKUs(categoryMapping);\n    \n    // Step 5: Migrate Items\n    const itemMapping = await migrateItems(skuMapping);\n    \n    // Step 6: Migrate Tags\n    await migrateTags(customerMapping, skuMapping);\n    \n    // Step 7: Create audit log\n    await createMigrationAuditLog();\n    \n    // Step 8: Validate results\n    const validation = await validateMigration();\n    \n    // Final report\n    const duration = Date.now() - migrationState.startTime.getTime();\n    log.info(`\\nðŸŽ‰ Migration completed in ${duration}ms`);\n    log.info('ðŸ“Š Final Statistics:');\n    Object.entries(migrationState.stats).forEach(([key, value]) => {\n      log.info(`  ${key}: ${value}`);\n    });\n    \n    if (migrationState.errors.length > 0) {\n      log.error(`âŒ ${migrationState.errors.length} errors occurred during migration`);\n      migrationState.errors.forEach(error => {\n        log.error(`  ${error.context}: ${error.error}`);\n      });\n    }\n    \n    if (migrationState.warnings.length > 0) {\n      log.warn(`âš ï¸  ${migrationState.warnings.length} warnings occurred during migration`);\n      migrationState.warnings.forEach(warning => {\n        log.warn(`  ${warning}`);\n      });\n    }\n    \n    log.info('âœ… Migration process complete!');\n    \n  } catch (error) {\n    log.error(`ðŸ’¥ Migration failed: ${error.message}`);\n    log.error(error.stack);\n    process.exit(1);\n  }\n}\n\n// CLI handling\nif (require.main === module) {\n  const args = process.argv.slice(2);\n  \n  // Parse command line arguments\n  args.forEach(arg => {\n    if (arg === '--dry-run') {\n      MIGRATION_CONFIG.dryRun = true;\n    } else if (arg === '--continue-on-error') {\n      MIGRATION_CONFIG.continueOnError = true;\n    } else if (arg.startsWith('--log-level=')) {\n      MIGRATION_CONFIG.logLevel = arg.split('=')[1];\n    }\n  });\n  \n  // Connect to database and run migration\n  const dbUri = process.env.MONGODB_URI || 'mongodb://localhost:27017/stockmanager_dev';\n  \n  mongoose.connect(dbUri)\n  .then(() => {\n    log.info(`Connected to database: ${dbUri}`);\n    return runMigration();\n  })\n  .then(() => {\n    process.exit(0);\n  })\n  .catch(error => {\n    log.error(`Database connection failed: ${error.message}`);\n    process.exit(1);\n  });\n}\n\nmodule.exports = {\n  runMigration,\n  MIGRATION_CONFIG\n};","line_range_start":1,"line_range_end":200}]
